
        
        """
void visitFunctionHeaders() {
      align(buf);
      f.functionHeaders =
          castArrayRef<SmallFuncHeader>(buf, h->functionCount, end);
          
            => https://github.com/facebook/hermes/blob/v0.12.0/include/hermes/BCGen/HBC/BytecodeFileFormat.h#L313
            
            https://github.com/facebook/hermes/blob/v0.12.0/include/hermes/BCGen/HBC/BytecodeFileFormat.h#L258
        """

            Note about the "environmentSize" attribute of the
            "SmallFuncHeader" structure:
            
                Its value is assigned to:
                        F->getFunctionScope()->getVariables().size(),
                It is serialized as an uint8_t within the small
                function header, but as an uint32_t within the
                internal state of the FunctionHeader structure.


        """°    °
        
        ==========
        
              BM.getBytecodeOptions()};
  writeBinary(header);
  // Sizes of file and function headers are tuned for good cache line packing.
  // If you reorder the format, try to avoid headers crossing cache lines.
  visitBytecodeSegmentsInOrder(*this);
        ==>
            void visitBytecodeSegmentsInOrder(Visitor &visitor) {
                  visitor.visitFunctionHeaders();
                  visitor.visitStringKinds();
                  visitor.visitIdentifierHashes();
                  visitor.visitSmallStringTable();
                  visitor.visitOverflowStringTable();
                  visitor.visitStringStorage();
                  visitor.visitArrayBuffer();
                  visitor.visitObjectKeyBuffer();
                  visitor.visitObjectValueBuffer();
                  visitor.visitBigIntTable();
                  visitor.visitBigIntStorage();
                  visitor.visitRegExpTable();
                  visitor.visitRegExpStorage();
                                    visitor.visitCJSModuleTable();
                  visitor.visitFunctionSourceTable();
                }
  serializeFunctionsBytecode(BM);
  
  
        // Overflowed function headers are put at the end
        // of the file
        
        // See logic here:
        // https://github.com/bongtrop/hbctool/blob/main/hbctool/hbc/hbc76/parser.py#L43


    Pas de point de jeudi, mais un point lundi prochain
    
        
  for (auto &entry : BM.getFunctionTable()) { // L'overflow va à la fin du fichier ?
    serializeFunctionInfo(*entry);
  }

  serializeDebugInfo(BM);
  
  =====
        https://github.com/facebook/hermes/blob/v0.12.0/lib/BCGen/HBC/BytecodeStream.cpp#L250
        
void BytecodeSerializer::visitFunctionHeaders() {
  pad(BYTECODE_ALIGNMENT);
  serializeFunctionTable(*bytecodeModule_);
        https://github.com/facebook/hermes/blob/v0.12.0/lib/BCGen/HBC/BytecodeStream.cpp#L80

void BytecodeSerializer::serializeFunctionTable(BytecodeModule &BM) {
  for (auto &entry : BM.getFunctionTable()) {

(As part of:)

// ============================ Function ============================
void BytecodeSerializer::serializeFunctionsBytecode(BytecodeModule &BM) {
  // Map from opcodes and jumptables to offsets, used to deduplicate bytecode.
  using DedupKey = llvh::ArrayRef<opcode_atom_t>;
  llvh::DenseMap<DedupKey, uint32_t> bcMap;
  for (auto &entry : BM.getFunctionTable()) {
    if (options_.optimizationEnabled) {
      // If identical bytecode exists, we'll reuse it.
      bool reuse = false;
      if (isLayout_) {
        // Deduplicate the bytecode during layout phase.
        DedupKey key = entry->getOpcodeArray();
        auto pair = bcMap.insert(std::make_pair(key, loc_));
        if (!pair.second) {
          reuse = true;
          entry->setOffset(pair.first->second);
        }
      } else {
        // Cheaply determine whether bytecode was deduplicated.
        assert(entry->getOffset() && "Function lacks offset after layout");
        assert(entry->getOffset() <= loc_ && "Function has too large offset");
        reuse = entry->getOffset() < loc_;
      }
      if (reuse) {
        continue;
      }
    }

    // Set the offset of this function's bytecode.
    if (isLayout_) {
      entry->setOffset(loc_);
    }

    // Serialize opcodes.
    writeBinaryArray(entry->getOpcodesOnly());

    // Serialize any jump table after the opcode block.
    if (!entry->getJumpTablesOnly().empty()) {
      pad(sizeof(uint32_t));
      writeBinaryArray(entry->getJumpTablesOnly());
    }
    if (options_.padFunctionBodiesPercent) {
      size_t size = entry->getOpcodesOnly().size();
      size = (size * options_.padFunctionBodiesPercent) / 100;
      while (size--)
        writeBinary('\0');
      pad(sizeof(uint32_t));
    }
  }
}

void BytecodeSerializer::serializeFunctionInfo(BytecodeFunction &BF) {
  // Set the offset of this function's info. Any subsection that is present is
  // aligned to INFO_ALIGNMENT, so we also align the recorded offset to that.
  if (isLayout_) {
    BF.setInfoOffset(llvh::alignTo(loc_, INFO_ALIGNMENT));
  }

  // Write large header if it doesn't fit in a small.
  FunctionHeader header = BF.getHeader();
  if (SmallFuncHeader(header).flags.overflowed) { <--
    pad(INFO_ALIGNMENT);
    writeBinary(header); <--
  }

  // Serialize exception handlers.
  serializeExceptionHandlerTable(BF);

  // Add offset in debug info (if function has debug info).
  serializeDebugOffsets(BF);
}

void BytecodeSerializer::visitFunctionHeaders() {
  pad(BYTECODE_ALIGNMENT);
  serializeFunctionTable(*bytecodeModule_);
}
        """
